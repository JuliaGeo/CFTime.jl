var documenterSearchIndex = {"docs":
[{"location":"example_CMIP6/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"This example shows how to use the CFTime package with CMIP6 data in the NetCDF format following the CF Conventions.","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"The CMIP6 example data is from NOAA-GFDL and data extracted at a single point as provided by the R package CFtime. The data is downloaded automatically.","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"This example can also be downloaded as a Julia source file example_CMIP6.jl.","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"using NCDatasets, CFTime, Dates, Statistics\nusing Downloads: download","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"Download the sample data and open the NetCDF file","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"url = \"https://github.com/R-CF/CFtime/raw/1509a2387a92bda8500d1d6ac472b36df3575b56/inst/extdata/pr_day_GFDL-ESM4_ssp245_r1i1p1f1_gr1_20150101-20991231_v20180701.nc\"\nfname = download(url);\nds = NCDataset(fname);","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"Get the global attriute Conventions","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"ds.attrib[\"Conventions\"]","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"\"CF-1.7 CMIP-6.0 UGRID-1.0\"","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"Get the calendar and units attriute of the variable time","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"calendar = ds[\"time\"].attrib[\"calendar\"]\nunits = ds[\"time\"].attrib[\"units\"]\n(calendar,units)","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"(\"noleap\", \"days since 1850-01-01\")","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"Load the raw data representing the number of days since 1850-01-01 with the noleap calendar and decode the data. The variable time is a vector of DateTimeNoLeap","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"data = ds[\"time\"].var[:];\ntime = CFTime.timedecode(data,units,calendar);\n(time[1],time[end])","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"(DateTimeNoLeap(2015-01-01T00:00:00)\n, DateTimeNoLeap(2099-12-31T00:00:00)\n)","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"Since CFTime is integrated in NCDatasets, this transformation above is handeld autmatically by using:","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"time = ds[\"time\"][:];","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"Load the precitipation which is a variable of the size 1 x 1 x 31025","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"pr = ds[\"pr\"][1,1,:];\npr_units = ds[\"pr\"].attrib[\"units\"];\nclose(ds);","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"Get all unique years and compute mean and standard deviation per year","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"years = unique(Dates.year.(time));\npr_yearly_mean = [mean(pr[Dates.year.(time) .== y]) for y in years];\npr_yearly_std = [std(pr[Dates.year.(time) .== y]) for y in years];","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"Plot the result","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"using CairoMakie\nfig = Figure()\nax = Axis(fig[1, 1],\n          xlabel = \"year\",\n          ylabel = \"precipitation ($(pr_units))\",\n          title = \"yearly mean and standard deviation of precipitation\")\n\nlines!(ax, years, pr_yearly_mean, label = \"yearly mean\")\nlines!(ax, years, pr_yearly_std, label = \"yearly standard deviation\")\naxislegend(ax, position = :lt)","category":"page"},{"location":"example_CMIP6/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"#CFTime.jl","page":"CFTime","title":"CFTime.jl","text":"","category":"section"},{"location":"","page":"CFTime","title":"CFTime","text":"In many Earth science disciplines and beyond, expressing a time instance and a duration is essential. The CF conventions provide a rich and flexible framework for handling time, equally applicable to observations and model data.","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"CFTime.jl implements the time structures standardized by the CF conventions, namely:","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"Julian calendar (DateTimeJulian). A year is a leap year if it is divisible by 4. For example, 1900 and 2000 are both leap years in the Julian calendar.\nProleptic Gregorian calendar (DateTimeProlepticGregorian). A year is a leap year if it is divisible by 4 but not 100 or if it is divisible by 400. For example, 1900 is not a leap year in the proleptic Gregorian calendar but 2000 is.\nMixed Gregorian/Julian calendar  (DateTimeStandard). This calendar uses the Julian calendar for time instances before 15th October 1582 and Gregorian calendar afterwards.\nA calendar without leap years (DateTimeNoLeap). All years are 365 days long.\nA calendar with only leap years (DateTimeAllLeap). All years are 366 days long.\nA calendar with every year being 360 days long (divided into 30-day months) (DateTime360Day).","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"The first three calendars (with different rules for leap years) can be used to express the time instances of observations or model. The remaining three calendars correspond to idealised model configurations where the duration of a year (revolution of the Earth around the Sun) is assumed to be exactly 365, 366 or 360 days.","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"While almost all datasets used in Earth Science use dates after the year 1582, some datasets or software systems use a time origin before this date, which makes it necessary to handle the transition from Julian to Gregorian calendar. Additionally, some dataset use microseconds and nanoseconds as time resolution, whereas Julia's Dates.DateTime has milliseconds as time resolution.","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"Note that time zones and leap seconds are currently not supported by CFTime.jl.","category":"page"},{"location":"#Installation","page":"CFTime","title":"Installation","text":"","category":"section"},{"location":"","page":"CFTime","title":"CFTime","text":"Inside the Julia shell, you can download and install the package by issuing:","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"using Pkg\nPkg.add(\"CFTime\")","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"CFTime is a pure Julia package and currently depends only on the modules Dates and Printf, which are part of Julia’s standard library.","category":"page"},{"location":"#Latest-development-version","page":"CFTime","title":"Latest development version","text":"","category":"section"},{"location":"","page":"CFTime","title":"CFTime","text":"If you want to try the latest development version, you can do this with the following commands:","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/JuliaGeo/CFTime.jl\", rev=\"master\"))","category":"page"},{"location":"#Types","page":"CFTime","title":"Types","text":"","category":"section"},{"location":"#CFTime.DateTimeStandard","page":"CFTime","title":"CFTime.DateTimeStandard","text":"DateTimeStandard([Ti::DataType], y, [m, d, h, mi, s, ms, µs, ns...],\n                 origin = (1900, 1, 1),\n                 units = ...) -> DateTimeStandard\n\nConstruct a DateTimeStandard type by year (y), month (m, default 1), day (d, default 1), hour (h, default 0), minute (mi, default 0), second (s, default 0), millisecond (ms, default 0), microsecond (µs, default 0), nanosecond (ns, default 0), .... Currently attosecond is the smallest supported time unit.\n\nAll arguments must be convertible to Int64. DateTimeStandard is a subtype of AbstractCFDateTime.\n\nThe date is stored a duration since the time origin (epoch) expressed as milliseconds but smaller time units will be used if necessary. For example if the user provides 8 integers, they will be interpreted as year, month, day, hour, minute, second, millisecond and microsecond. The internal time units will be microsecond in this case.\n\nValid values for units are :day, :hour, :second, ..., :attosecond as symbols or value types of symbols (e.g. Val(:day)).\n\norigin is a tuple of integers representing the year, month and day as well as smaller time divisions if necessary.\n\nThe duration is stored as a number of type Ti (Int64 per default). Any integers types (such as Int32, Int128 or BigInt) or floating-point types can be used. Using an integer to encode a time instance is recommended for most applications, as it makes reasoning about the time resolution easier.\n\nExample:\n\nusing CFTime\n\n# 31st December 2000, 00:00:00 using the CF calendaro \"standard\"\n# The internal time unit is millisecond.\ndt1 = DateTimeStandard(2000,12,31)\n\n# 31st December 2000, 00:00:00 and 1 nanosecond.\n# The internal time unit is nanosecond.\ndt2 = DateTimeStandard(2000,12,31, 0,0,0, 0,0,1)\n\ndt2 - dt1\n# output: 1 nanosecond\n\n# 31st December 2000, 00:00:00\n# The internal time unit is microsecond. Internally the duration is stored\n# as an Int128.\ndt3 = DateTimeStandard(Int128, 2000,12,31, units = :microsecond)\n\ndt1 == dt3\n# output: true\n\nThe netCDF CF calendars are defined in the CF Standard. This type implements the calendar defined as \"standard\".\n\n\n\n\n\nDateTimeStandard(dt::AbstractString, format::AbstractString;\n                 locale=\"english\") -> DateTimeStandard\n\nConstruct a DateTimeStandard by parsing the dt date time string following the pattern given in the format string. In Julia, the only currently defined locale is English, therefore locale must be \"english\" or omitted.\n\nSee Dates.DateFormat for more information about the date time and format string.\n\nExample:\n\nusing CFTime\n\n# 31st December 2000\ndt1 = DateTimeStandard(\"2000-December-31\",\"yyyy-U-dd\")\n\nnote: Note\nThis function is experimental and might be removed in the future. It relies on some internal function of Dates for parsing the format.\n\n\n\n\n\n","category":"type"},{"location":"#CFTime.DateTimeJulian","page":"CFTime","title":"CFTime.DateTimeJulian","text":"DateTimeJulian([Ti::DataType], y, [m, d, h, mi, s, ms, µs, ns...],\n               origin = (1900, 1, 1),\n               units = ...) -> DateTimeJulian\n\nConstruct a DateTimeJulian type by year (y), month (m, default 1), day (d, default 1), hour (h, default 0), minute (mi, default 0), second (s, default 0), millisecond (ms, default 0), microsecond (µs, default 0), nanosecond (ns, default 0), .... Currently attosecond is the smallest supported time unit.\n\nAll arguments must be convertible to Int64. DateTimeJulian is a subtype of AbstractCFDateTime.\n\nThe date is stored a duration since the time origin (epoch) expressed as milliseconds but smaller time units will be used if necessary. For example if the user provides 8 integers, they will be interpreted as year, month, day, hour, minute, second, millisecond and microsecond. The internal time units will be microsecond in this case.\n\nValid values for units are :day, :hour, :second, ..., :attosecond as symbols or value types of symbols (e.g. Val(:day)).\n\norigin is a tuple of integers representing the year, month and day as well as smaller time divisions if necessary.\n\nThe duration is stored as a number of type Ti (Int64 per default). Any integers types (such as Int32, Int128 or BigInt) or floating-point types can be used. Using an integer to encode a time instance is recommended for most applications, as it makes reasoning about the time resolution easier.\n\nExample:\n\nusing CFTime\n\n# 31st December 2000, 00:00:00 using the CF calendaro \"julian\"\n# The internal time unit is millisecond.\ndt1 = DateTimeJulian(2000,12,31)\n\n# 31st December 2000, 00:00:00 and 1 nanosecond.\n# The internal time unit is nanosecond.\ndt2 = DateTimeJulian(2000,12,31, 0,0,0, 0,0,1)\n\ndt2 - dt1\n# output: 1 nanosecond\n\n# 31st December 2000, 00:00:00\n# The internal time unit is microsecond. Internally the duration is stored\n# as an Int128.\ndt3 = DateTimeJulian(Int128, 2000,12,31, units = :microsecond)\n\ndt1 == dt3\n# output: true\n\nThe netCDF CF calendars are defined in the CF Standard. This type implements the calendar defined as \"julian\".\n\n\n\n\n\nDateTimeJulian(dt::AbstractString, format::AbstractString;\n               locale=\"english\") -> DateTimeJulian\n\nConstruct a DateTimeJulian by parsing the dt date time string following the pattern given in the format string. In Julia, the only currently defined locale is English, therefore locale must be \"english\" or omitted.\n\nSee Dates.DateFormat for more information about the date time and format string.\n\nExample:\n\nusing CFTime\n\n# 31st December 2000\ndt1 = DateTimeStandard(\"2000-December-31\",\"yyyy-U-dd\")\n\nnote: Note\nThis function is experimental and might be removed in the future. It relies on some internal function of Dates for parsing the format.\n\n\n\n\n\n","category":"type"},{"location":"#CFTime.DateTimeProlepticGregorian","page":"CFTime","title":"CFTime.DateTimeProlepticGregorian","text":"DateTimeProlepticGregorian([Ti::DataType], y, [m, d, h, mi, s, ms, µs, ns...],\n                           origin = (1900, 1, 1),\n                           units = ...) -> DateTimeProlepticGregorian\n\nConstruct a DateTimeProlepticGregorian type by year (y), month (m, default 1), day (d, default 1), hour (h, default 0), minute (mi, default 0), second (s, default 0), millisecond (ms, default 0), microsecond (µs, default 0), nanosecond (ns, default 0), .... Currently attosecond is the smallest supported time unit.\n\nAll arguments must be convertible to Int64. DateTimeProlepticGregorian is a subtype of AbstractCFDateTime.\n\nThe date is stored a duration since the time origin (epoch) expressed as milliseconds but smaller time units will be used if necessary. For example if the user provides 8 integers, they will be interpreted as year, month, day, hour, minute, second, millisecond and microsecond. The internal time units will be microsecond in this case.\n\nValid values for units are :day, :hour, :second, ..., :attosecond as symbols or value types of symbols (e.g. Val(:day)).\n\norigin is a tuple of integers representing the year, month and day as well as smaller time divisions if necessary.\n\nThe duration is stored as a number of type Ti (Int64 per default). Any integers types (such as Int32, Int128 or BigInt) or floating-point types can be used. Using an integer to encode a time instance is recommended for most applications, as it makes reasoning about the time resolution easier.\n\nExample:\n\nusing CFTime\n\n# 31st December 2000, 00:00:00 using the CF calendaro \"prolepticgregorian\"\n# The internal time unit is millisecond.\ndt1 = DateTimeProlepticGregorian(2000,12,31)\n\n# 31st December 2000, 00:00:00 and 1 nanosecond.\n# The internal time unit is nanosecond.\ndt2 = DateTimeProlepticGregorian(2000,12,31, 0,0,0, 0,0,1)\n\ndt2 - dt1\n# output: 1 nanosecond\n\n# 31st December 2000, 00:00:00\n# The internal time unit is microsecond. Internally the duration is stored\n# as an Int128.\ndt3 = DateTimeProlepticGregorian(Int128, 2000,12,31, units = :microsecond)\n\ndt1 == dt3\n# output: true\n\nThe netCDF CF calendars are defined in the CF Standard. This type implements the calendar defined as \"prolepticgregorian\".\n\n\n\n\n\nDateTimeProlepticGregorian(dt::AbstractString, format::AbstractString;\n                           locale=\"english\") -> DateTimeProlepticGregorian\n\nConstruct a DateTimeProlepticGregorian by parsing the dt date time string following the pattern given in the format string. In Julia, the only currently defined locale is English, therefore locale must be \"english\" or omitted.\n\nSee Dates.DateFormat for more information about the date time and format string.\n\nExample:\n\nusing CFTime\n\n# 31st December 2000\ndt1 = DateTimeStandard(\"2000-December-31\",\"yyyy-U-dd\")\n\nnote: Note\nThis function is experimental and might be removed in the future. It relies on some internal function of Dates for parsing the format.\n\n\n\n\n\n","category":"type"},{"location":"#CFTime.DateTimeAllLeap","page":"CFTime","title":"CFTime.DateTimeAllLeap","text":"DateTimeAllLeap([Ti::DataType], y, [m, d, h, mi, s, ms, µs, ns...],\n                origin = (1900, 1, 1),\n                units = ...) -> DateTimeAllLeap\n\nConstruct a DateTimeAllLeap type by year (y), month (m, default 1), day (d, default 1), hour (h, default 0), minute (mi, default 0), second (s, default 0), millisecond (ms, default 0), microsecond (µs, default 0), nanosecond (ns, default 0), .... Currently attosecond is the smallest supported time unit.\n\nAll arguments must be convertible to Int64. DateTimeAllLeap is a subtype of AbstractCFDateTime.\n\nThe date is stored a duration since the time origin (epoch) expressed as milliseconds but smaller time units will be used if necessary. For example if the user provides 8 integers, they will be interpreted as year, month, day, hour, minute, second, millisecond and microsecond. The internal time units will be microsecond in this case.\n\nValid values for units are :day, :hour, :second, ..., :attosecond as symbols or value types of symbols (e.g. Val(:day)).\n\norigin is a tuple of integers representing the year, month and day as well as smaller time divisions if necessary.\n\nThe duration is stored as a number of type Ti (Int64 per default). Any integers types (such as Int32, Int128 or BigInt) or floating-point types can be used. Using an integer to encode a time instance is recommended for most applications, as it makes reasoning about the time resolution easier.\n\nExample:\n\nusing CFTime\n\n# 31st December 2000, 00:00:00 using the CF calendaro \"allleap\"\n# The internal time unit is millisecond.\ndt1 = DateTimeAllLeap(2000,12,31)\n\n# 31st December 2000, 00:00:00 and 1 nanosecond.\n# The internal time unit is nanosecond.\ndt2 = DateTimeAllLeap(2000,12,31, 0,0,0, 0,0,1)\n\ndt2 - dt1\n# output: 1 nanosecond\n\n# 31st December 2000, 00:00:00\n# The internal time unit is microsecond. Internally the duration is stored\n# as an Int128.\ndt3 = DateTimeAllLeap(Int128, 2000,12,31, units = :microsecond)\n\ndt1 == dt3\n# output: true\n\nThe netCDF CF calendars are defined in the CF Standard. This type implements the calendar defined as \"allleap\".\n\n\n\n\n\nDateTimeAllLeap(dt::AbstractString, format::AbstractString;\n                locale=\"english\") -> DateTimeAllLeap\n\nConstruct a DateTimeAllLeap by parsing the dt date time string following the pattern given in the format string. In Julia, the only currently defined locale is English, therefore locale must be \"english\" or omitted.\n\nSee Dates.DateFormat for more information about the date time and format string.\n\nExample:\n\nusing CFTime\n\n# 31st December 2000\ndt1 = DateTimeStandard(\"2000-December-31\",\"yyyy-U-dd\")\n\nnote: Note\nThis function is experimental and might be removed in the future. It relies on some internal function of Dates for parsing the format.\n\n\n\n\n\n","category":"type"},{"location":"#CFTime.DateTimeNoLeap","page":"CFTime","title":"CFTime.DateTimeNoLeap","text":"DateTimeNoLeap([Ti::DataType], y, [m, d, h, mi, s, ms, µs, ns...],\n               origin = (1900, 1, 1),\n               units = ...) -> DateTimeNoLeap\n\nConstruct a DateTimeNoLeap type by year (y), month (m, default 1), day (d, default 1), hour (h, default 0), minute (mi, default 0), second (s, default 0), millisecond (ms, default 0), microsecond (µs, default 0), nanosecond (ns, default 0), .... Currently attosecond is the smallest supported time unit.\n\nAll arguments must be convertible to Int64. DateTimeNoLeap is a subtype of AbstractCFDateTime.\n\nThe date is stored a duration since the time origin (epoch) expressed as milliseconds but smaller time units will be used if necessary. For example if the user provides 8 integers, they will be interpreted as year, month, day, hour, minute, second, millisecond and microsecond. The internal time units will be microsecond in this case.\n\nValid values for units are :day, :hour, :second, ..., :attosecond as symbols or value types of symbols (e.g. Val(:day)).\n\norigin is a tuple of integers representing the year, month and day as well as smaller time divisions if necessary.\n\nThe duration is stored as a number of type Ti (Int64 per default). Any integers types (such as Int32, Int128 or BigInt) or floating-point types can be used. Using an integer to encode a time instance is recommended for most applications, as it makes reasoning about the time resolution easier.\n\nExample:\n\nusing CFTime\n\n# 31st December 2000, 00:00:00 using the CF calendaro \"noleap\"\n# The internal time unit is millisecond.\ndt1 = DateTimeNoLeap(2000,12,31)\n\n# 31st December 2000, 00:00:00 and 1 nanosecond.\n# The internal time unit is nanosecond.\ndt2 = DateTimeNoLeap(2000,12,31, 0,0,0, 0,0,1)\n\ndt2 - dt1\n# output: 1 nanosecond\n\n# 31st December 2000, 00:00:00\n# The internal time unit is microsecond. Internally the duration is stored\n# as an Int128.\ndt3 = DateTimeNoLeap(Int128, 2000,12,31, units = :microsecond)\n\ndt1 == dt3\n# output: true\n\nThe netCDF CF calendars are defined in the CF Standard. This type implements the calendar defined as \"noleap\".\n\n\n\n\n\nDateTimeNoLeap(dt::AbstractString, format::AbstractString;\n               locale=\"english\") -> DateTimeNoLeap\n\nConstruct a DateTimeNoLeap by parsing the dt date time string following the pattern given in the format string. In Julia, the only currently defined locale is English, therefore locale must be \"english\" or omitted.\n\nSee Dates.DateFormat for more information about the date time and format string.\n\nExample:\n\nusing CFTime\n\n# 31st December 2000\ndt1 = DateTimeStandard(\"2000-December-31\",\"yyyy-U-dd\")\n\nnote: Note\nThis function is experimental and might be removed in the future. It relies on some internal function of Dates for parsing the format.\n\n\n\n\n\n","category":"type"},{"location":"#CFTime.DateTime360Day","page":"CFTime","title":"CFTime.DateTime360Day","text":"DateTime360Day([Ti::DataType], y, [m, d, h, mi, s, ms, µs, ns...],\n               origin = (1900, 1, 1),\n               units = ...) -> DateTime360Day\n\nConstruct a DateTime360Day type by year (y), month (m, default 1), day (d, default 1), hour (h, default 0), minute (mi, default 0), second (s, default 0), millisecond (ms, default 0), microsecond (µs, default 0), nanosecond (ns, default 0), .... Currently attosecond is the smallest supported time unit.\n\nAll arguments must be convertible to Int64. DateTime360Day is a subtype of AbstractCFDateTime.\n\nThe date is stored a duration since the time origin (epoch) expressed as milliseconds but smaller time units will be used if necessary. For example if the user provides 8 integers, they will be interpreted as year, month, day, hour, minute, second, millisecond and microsecond. The internal time units will be microsecond in this case.\n\nValid values for units are :day, :hour, :second, ..., :attosecond as symbols or value types of symbols (e.g. Val(:day)).\n\norigin is a tuple of integers representing the year, month and day as well as smaller time divisions if necessary.\n\nThe duration is stored as a number of type Ti (Int64 per default). Any integers types (such as Int32, Int128 or BigInt) or floating-point types can be used. Using an integer to encode a time instance is recommended for most applications, as it makes reasoning about the time resolution easier.\n\nExample:\n\nusing CFTime\n\n# 31st December 2000, 00:00:00 using the CF calendaro \"360day\"\n# The internal time unit is millisecond.\ndt1 = DateTime360Day(2000,12,31)\n\n# 31st December 2000, 00:00:00 and 1 nanosecond.\n# The internal time unit is nanosecond.\ndt2 = DateTime360Day(2000,12,31, 0,0,0, 0,0,1)\n\ndt2 - dt1\n# output: 1 nanosecond\n\n# 31st December 2000, 00:00:00\n# The internal time unit is microsecond. Internally the duration is stored\n# as an Int128.\ndt3 = DateTime360Day(Int128, 2000,12,31, units = :microsecond)\n\ndt1 == dt3\n# output: true\n\nThe netCDF CF calendars are defined in the CF Standard. This type implements the calendar defined as \"360day\".\n\n\n\n\n\nDateTime360Day(dt::AbstractString, format::AbstractString;\n               locale=\"english\") -> DateTime360Day\n\nConstruct a DateTime360Day by parsing the dt date time string following the pattern given in the format string. In Julia, the only currently defined locale is English, therefore locale must be \"english\" or omitted.\n\nSee Dates.DateFormat for more information about the date time and format string.\n\nExample:\n\nusing CFTime\n\n# 31st December 2000\ndt1 = DateTimeStandard(\"2000-December-31\",\"yyyy-U-dd\")\n\nnote: Note\nThis function is experimental and might be removed in the future. It relies on some internal function of Dates for parsing the format.\n\n\n\n\n\n","category":"type"},{"location":"#Time-encoding-and-decoding","page":"CFTime","title":"Time encoding and decoding","text":"","category":"section"},{"location":"#CFTime.timedecode","page":"CFTime","title":"CFTime.timedecode","text":"dt = timedecode(data,units,calendar = \"standard\"; prefer_datetime = true)\n\nDecode the time information in data as given by the units units according to the specified calendar.\n\nunits has the format \"DURATION_UNIT since TIME_ORIGIN\" where DURATION_UNIT can be the year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, picosecond, femtosecond or attosecond (in singular or plural). The string TIME_ORIGIN is a time instance written as year-month-day hour:minute:second.subseconds...  using 24-hour clock system where subseconds is the decimal fraction of the second. day and hour can also be separated by the character T following ISO 8601.\n\nValid values for calendar are \"standard\", \"gregorian\", \"proleptic_gregorian\", \"julian\", \"noleap\", \"365_day\", \"all_leap\", \"366_day\" and \"360_day\".\n\nIf prefer_datetime is true (default), dates are converted to the DateTime type (for the calendars \"standard\", \"gregorian\", \"proleptic_gregorian\" and \"julian\") unless the time unit is expressed in microseconds or smaller. Such conversion is not possible for the other calendars.\n\nCalendar Type (prefer_datetime=true) Type (prefer_datetime=false)\nstandard, gregorian DateTime DateTimeStandard\nproleptic_gregorian DateTime DateTimeProlepticGregorian\njulian DateTime DateTimeJulian\nnoleap, 365_day DateTimeNoLeap DateTimeNoLeap\nall_leap, 366_day DateTimeAllLeap DateTimeAllLeap\n360_day DateTime360Day DateTime360Day\n\nExample:\n\nusing CFTime, Dates\n# standard calendar\ndt = CFTime.timedecode([0,1,2,3],\"days since 2000-01-01 00:00:00\")\n# 4-element Array{Dates.DateTime,1}:\n#  2000-01-01T00:00:00\n#  2000-01-02T00:00:00\n#  2000-01-03T00:00:00\n#  2000-01-04T00:00:00\n\ndt = CFTime.timedecode([0,1,2,3],\"days since 2000-01-01 00:00:00\",\"360_day\")\n# 4-element Array{DateTime360Day,1}:\n#  DateTime360Day(2000-01-01T00:00:00)\n#  DateTime360Day(2000-01-02T00:00:00)\n#  DateTime360Day(2000-01-03T00:00:00)\n#  DateTime360Day(2000-01-04T00:00:00)\n\n\n\n\n\n","category":"function"},{"location":"#CFTime.timeencode","page":"CFTime","title":"CFTime.timeencode","text":"data = timeencode(dt,units,calendar = \"standard\")\n\nConvert a vector or array of DateTime (or DateTimeStandard, DateTimeProlepticGregorian, DateTimeJulian, DateTimeNoLeap, DateTimeAllLeap, DateTime360Day) according to the specified units (e.g. \"days since 2000-01-01 00:00:00\") using the calendar calendar.\n\nunits has the format \"DURATION_UNIT since TIME_ORIGIN\" where DURATION_UNIT can be the year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, picosecond, femtosecond or attosecond (in singular or plural). The string TIME_ORIGIN is a time instance written as year-month-day hour:minute:second.subseconds...  using 24-hour clock system where subseconds is the decimal fraction of the second. day and hour can also be separated by the character T following ISO 8601.\n\nValid values for calendar are: \"standard\", \"gregorian\", \"proleptic_gregorian\", \"julian\", \"noleap\", \"365_day\", \"all_leap\", \"366_day\", \"360_day\".\n\nExample:\n\nusing CFTime\ndt = [DateTimeStandard(2000,1,1),DateTimeStandard(2000,1,2),DateTimeStandard(2000,1,3)]\nCFTime.timeencode(dt,\"days since 2000-01-01 00:00:00\")\n# output: [0., 1., 2.]\n\n\n\n\n\n","category":"function"},{"location":"#Accessor-Functions","page":"CFTime","title":"Accessor Functions","text":"","category":"section"},{"location":"#Dates.year-Tuple{AbstractCFDateTime}","page":"CFTime","title":"Dates.year","text":"Dates.year(dt::AbstractCFDateTime) -> Int64\n\nExtract the year part of an AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.month-Tuple{AbstractCFDateTime}","page":"CFTime","title":"Dates.month","text":"Dates.month(dt::AbstractCFDateTime) -> Int64\n\nExtract the month part of an AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.day-Tuple{AbstractCFDateTime}","page":"CFTime","title":"Dates.day","text":"Dates.day(dt::AbstractCFDateTime) -> Int64\n\nExtract the day part of an AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.hour-Tuple{AbstractCFDateTime}","page":"CFTime","title":"Dates.hour","text":"Dates.hour(dt::AbstractCFDateTime) -> Int64\n\nExtract the hour part of an AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.minute-Tuple{AbstractCFDateTime}","page":"CFTime","title":"Dates.minute","text":"Dates.minute(dt::AbstractCFDateTime) -> Int64\n\nExtract the minute part of an AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.second-Tuple{AbstractCFDateTime}","page":"CFTime","title":"Dates.second","text":"Dates.second(dt::AbstractCFDateTime) -> Int64\n\nExtract the second part of an AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.millisecond-Tuple{AbstractCFDateTime}","page":"CFTime","title":"Dates.millisecond","text":"Dates.millisecond(dt::AbstractCFDateTime) -> Int64\n\nExtract the millisecond part of an AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.microsecond-Tuple{AbstractCFDateTime}","page":"CFTime","title":"Dates.microsecond","text":"Dates.microsecond(dt::AbstractCFDateTime) -> Int64\n\nExtract the microsecond part of an AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.nanosecond-Tuple{AbstractCFDateTime}","page":"CFTime","title":"Dates.nanosecond","text":"Dates.nanosecond(dt::AbstractCFDateTime) -> Int64\n\nExtract the nanosecond part of an AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#CFTime.picosecond-Tuple{AbstractCFDateTime}","page":"CFTime","title":"CFTime.picosecond","text":"CFTime.picosecond(dt::AbstractCFDateTime) -> Int64\n\nExtract the picosecond part of an AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#CFTime.femtosecond-Tuple{AbstractCFDateTime}","page":"CFTime","title":"CFTime.femtosecond","text":"CFTime.femtosecond(dt::AbstractCFDateTime) -> Int64\n\nExtract the femtosecond part of an AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#CFTime.attosecond-Tuple{AbstractCFDateTime}","page":"CFTime","title":"CFTime.attosecond","text":"CFTime.attosecond(dt::AbstractCFDateTime) -> Int64\n\nExtract the attosecond part of an AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Query-Functions","page":"CFTime","title":"Query Functions","text":"","category":"section"},{"location":"#Dates.daysinmonth","page":"CFTime","title":"Dates.daysinmonth","text":"monthlength = daysinmonth(::Type{DT},y,m)\n\nReturns the number of days in a month for the year y and the month m according to the calendar given by the type DT.\n\nExample\n\njulia> daysinmonth(DateTimeAllLeap,2001,2)\n29\n\n\n\n\n\nmonthlength = daysinmonth(t)\n\nReturns the number of days in a month containing the date t\n\nExample\n\njulia> daysinmonth(DateTimeAllLeap(2001,2,1))\n29\n\n\n\n\n\n","category":"function"},{"location":"#Dates.daysinyear","page":"CFTime","title":"Dates.daysinyear","text":"yearlength = daysinyear(::Type{DT},y)\n\nReturns the number of days in a year for the year y according to the calendar given by the type DT.\n\nExample\n\njulia> daysinyear(DateTimeAllLeap,2001,2)\n366\n\n\n\n\n\nyearlength = daysinyear(t)\n\nReturns the number of days in a year containing the date t\n\nExample\n\njulia> daysinyear(DateTimeAllLeap(2001,2,1))\n366\n\n\n\n\n\n","category":"function"},{"location":"#Dates.yearmonthday","page":"CFTime","title":"Dates.yearmonthday","text":"yearmonthday(dt::AbstractCFDateTime) -> (Int64, Int64, Int64)\n\nSimultaneously return the year, month and day parts of dt.\n\n\n\n\n\n","category":"function"},{"location":"#Dates.yearmonth","page":"CFTime","title":"Dates.yearmonth","text":"yearmonth(dt::AbstractCFDateTime) -> (Int64, Int64)\n\nSimultaneously return the year and month parts of dt.\n\n\n\n\n\n","category":"function"},{"location":"#Dates.monthday","page":"CFTime","title":"Dates.monthday","text":"monthday(dt::AbstractCFDateTime) -> (Int64, Int64)\n\nSimultaneously return the month and day parts of dt.\n\n\n\n\n\n","category":"function"},{"location":"#Dates.firstdayofyear","page":"CFTime","title":"Dates.firstdayofyear","text":"firstdayofyear(dt::AbstractCFDateTime) -> Int\n\nReturn the first day of the year including the date dt\n\n\n\n\n\n","category":"function"},{"location":"#Dates.dayofyear","page":"CFTime","title":"Dates.dayofyear","text":"dayofyear(dt::AbstractCFDateTime) -> Int\n\nReturn the day of the year for dt with January 1st being day 1.\n\n\n\n\n\n","category":"function"},{"location":"#Convertion-Functions","page":"CFTime","title":"Convertion Functions","text":"","category":"section"},{"location":"","page":"CFTime","title":"CFTime","text":"The flexibility of CFTime's datetime (related to the time origin, time resolution and type of the time counter) comes with some cost. When merging data from different sources, the resulting merged time vector may not have a concrete type, as there is no implicit conversion to a common time origin or internal unit, unlike Julia's DateTime. In some cases, the user might decide to explicitly convert all times to a common time origin and internal unit for optimal performance.","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"The convert function can be used to convert dates between the different calendars:","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"using CFTime, Dates\nconvert(DateTime,DateTimeJulian(2024,4,4))\n# 2024-04-17T00:00:00\n\nconvert(DateTimeJulian,DateTime(2024,4,17))\n# DateTimeJulian(2024-04-04T00:00:00)","category":"page"},{"location":"#Base.convert-Tuple{Type{DateTime}, DateTimeStandard}","page":"CFTime","title":"Base.convert","text":"dt2 = convert(::Type{T}, dt)\n\nConvert a DateTime dt of type DateTimeStandard, DateTimeProlepticGregorian, DateTimeJulian or DateTime into the type T which can also be either DateTimeStandard, DateTimeProlepticGregorian, DateTimeJulian or DateTime.\n\nConversion is done such that duration (difference of DateTime types) are preserved. For dates on and after 1582-10-15, the year, month and days are the same for the types DateTimeStandard, DateTimeProlepticGregorian and DateTime.\n\nFor dates before 1582-10-15, the year, month and days are the same for the types DateTimeStandard and DateTimeJulian.\n\n\n\n\n\n","category":"method"},{"location":"#Base.reinterpret","page":"CFTime","title":"Base.reinterpret","text":"dt2 = reinterpret(::Type{T}, dt)\n\nConvert a variable dt of type DateTime, DateTimeStandard, DateTimeJulian, DateTimeProlepticGregorian, DateTimeAllLeap, DateTimeNoLeap or DateTime360Day into the date time type T using the same values for year, month, day, minute, second, ... attosecond. The conversion might fail if a particular date does not exist in the target calendar.\n\nFor example, the difference of the 1 January 2000 in the Julian and and the 1 January 2000 in the standard calendar is 13 days:\n\nusing CFTime, Dates\ndt = DateTimeJulian(2000,1,1)\nDates.Day(dt - reinterpret(DateTimeStandard,dt))\n# 13 days\n\n\n\n\n\n","category":"function"},{"location":"#Arithmetic","page":"CFTime","title":"Arithmetic","text":"","category":"section"},{"location":"","page":"CFTime","title":"CFTime","text":"Adding and subtracting time periods is supported:","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"DateTimeStandard(1582,10,4) + Dates.Day(1)\n# returns DateTimeStandard(1582-10-15T00:00:00)","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"1582-10-15 is the adoption of the Gregorian Calendar.","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"Comparision operator can be used to check if a date is before or after another date.","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"DateTimeStandard(2000,01,01) < DateTimeStandard(2000,01,02)\n# returns true","category":"page"},{"location":"#Ranges","page":"CFTime","title":"Ranges","text":"","category":"section"},{"location":"","page":"CFTime","title":"CFTime","text":"Time ranges can be constructed using a start date, end date and a time increment:","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"range = DateTimeStandard(2000,1,1):Dates.Day(1):DateTimeStandard(2000,12,31)\nlength(range)\n# returns 366\nstep(range)\n# returns 1 day","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"Note that there is no default increment for range.","category":"page"},{"location":"#Rounding","page":"CFTime","title":"Rounding","text":"","category":"section"},{"location":"","page":"CFTime","title":"CFTime","text":"Julia's DateTime records the time relative to a time orgin (January 1st, 1 BC or 0000-01-01 in ISO_8601) with a millisecond accuracy. Converting CFTime date time structures to Julia's DateTime (using convert(DateTime,dt)) can trigger an inexact exception if the convertion cannot be done without loss of precision. One can use the round function in order to round to the nearest time represenatable by DateTime:","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"using CFTime: DateTimeStandard\nusing Dates: DateTime\ndt = DateTimeStandard(24*60*60*1000*1000 + 123,\"microsecond since 2000-01-01\")\nround(DateTime,dt)\n# output\n\n2000-01-02T00:00:00","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"The functions floor and ceil are also supported. They can be used to effectively reduce the time resolution, for example:","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"using CFTime: DateTimeStandard\n\ndt = DateTimeStandard(24*60*60,\"second since 2000-01-01\")\n\nfloor(dt+Second(9),Second(10)) == dt\n# output\n\ntrue\n\nceil(dt+Second(9),Second(10)) == dt + Second(10)\n# output\n\ntrue\n\nround(dt+Second(9),Second(10)) == dt + Second(10)\n# output\n\ntrue","category":"page"},{"location":"#Type-stable-constructors","page":"CFTime","title":"Type-stable constructors","text":"","category":"section"},{"location":"","page":"CFTime","title":"CFTime","text":"To create a type-stable date time structure, use the DateTimeStandard (and similar) either with the default units and time origin, a constant unit/origin or a value type of the unit and origin. For example:","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"using CFTime: DateTimeStandard\n\nfunction foo(year,month,day,hour,minute,second)\n   DateTimeStandard(year,month,day,hour,minute,second;\n                    units=:second, origin=(1970,1,1))\nend\n\n# Type-stable thanks to constant propagation\n@code_warntype foo(2000,1,1,0,0,0)\n\n\nfunction foo2(year,month,day,hour,minute,second,units,origin)\n   DateTimeStandard(year,month,day,hour,minute,second; units, origin)\nend\n\n# This not type-stable as the type depends on the value of units and origin\nunits = :second\norigin = (1970,1,1)\n@code_warntype foo2(2000,1,1,0,0,0,units,origin)\n\n\n# But this is again type-stable\nunits = Val(:second)\norigin = Val((1970,1,1))\n@code_warntype foo2(2000,1,1,0,0,0,units,origin)","category":"page"},{"location":"#Internal-API","page":"CFTime","title":"Internal API","text":"","category":"section"},{"location":"","page":"CFTime","title":"CFTime","text":"For CFTime 0.1.4 and before all date-times are encoded using internally milliseconds since a fixed time origin and stored as an Int64 similar to julia's Dates.DateTime. However, this approach does not allow to encode time with a sub-millisecond precision allowed by the CF convention and supported by e.g. numpy. While numpy allows attosecond precision, it can only encode a time span of ±9.2 around the date 00:00:00 UTC on 1 January 1970. In CFTime the time origin and the number containing the duration and the time precision are now encoded as two additional type parameters.","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"When wrapping a CFTime date-time type, it is recommended for performance reasons to make the containg structure also parametric, for example","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"struct MyStuct{T1,T2}\n  dt::DateTimeStandard{T1,T2}\nend","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"Future version of CFTime might add other type parameters. Internally, T1 corresponds to a CFTime.Period{T,Tfactor,Texponent} structure  wrapping a number type T representing the duration expressed in seconds as:","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"duration * factor * 10^exponent","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"where Tfactor and Texponent are value types of factor and exponent respectively.","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"For example, duration 3600000 milliseconds is represented as duration = 3600000, Tfactor = Val(1), Texponent = Val(-3), as","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"3600000 milliseconds = 3600000 * 1 * 10⁻³ seconds","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"or the duration 1 hours is duration = 1,  Tfactor = Val(3600) and Texponent = Val(0) since:","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"1 hour = 3600 * 1 * 10⁰ seconds","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"There is no normalization of the time duration per default as it could lead to under-/overflow.","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"The type parameter T2 of DateTimeStandard encodes the time origin as a tuple of integers starting with the year (year,month,day,hour,minute,seconds,...attoseconds).  Only the year, month and day need specified; all other default to zero. For example T2 would be Val((1970,1,1)) if the time origin is the 1st January 1970.","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"By using value types as type parametes, the time origin, time resolution... are known to the compiler. For example, computing the difference between between two date time expressed in as the same time origin and units as a single substraction:","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"using BenchmarkTools\nusing Dates\nusing CFTime: DateTimeStandard\n\ndt0 = DateTimeStandard(1,\"days since 2000-01-01\")\ndt1 = DateTimeStandard(1000,\"days since 2000-01-01\")\n\ndifference_datetime(dt0,dt1) = Dates.Millisecond(dt1 - dt0).value\n@btime difference_datetime($dt0,$dt1)\n\n# output (minimum of 5 @btime trails)\n# 1.689 ns (0 allocations: 0 bytes)\n\nv0 = 1\nv1 = 1000\n\ndifference_numbers(v0,v1) = (v1-v0)*(86_400_000)\n@btime difference_numbers($v0,$v1)\n\n# output (minimum of 5 @btime trails)\n# 1.683 ns (0 allocations: 0 bytes)","category":"page"},{"location":"","page":"CFTime","title":"CFTime","text":"The information in this section and any other information marked as internal or experimental is not part of the public API and not covered by the semantic versioning. Future version of CFTime might add or changing the meaning of type parameters as patch-level changes. However removing a type parameter would be considered as a breaking change.","category":"page"}]
}
